@* File: Chat.razor *@
@page "/Chat"
@using m1Chat.Client.Components
@using m1Chat.Client.Services
@inject IScrollManager ScrollManager
@inject ChatCompletionService CompletionService
@inject ChatService ChatService
@inject IJSRuntime Js
@using ServiceChatMessage = m1Chat.Client.Services.ChatMessage
@inject UserService UserService
@inject ISnackbar Snackbar
@inject NavigationManager NavigationManager


<MudLayout>
  <ChatDrawer @bind-DrawerOpen="_drawerOpen"
              SidebarChats="SidebarChats"
              UserEmail="@UserEmail"
              ActiveChatId="@_chatId"
              OnChatSelected="LoadChat"
              OnCreateNewChat="CreateNewChat"
              OnChatPinned="PinChat"
              OnChatDeleted="DeleteChat"
              OnChatRenamed="HandleChatRenamed"/>

  <MudMainContent
    Class="d-flex flex-column p-0 chat-main-content-bg"
    Style="height:100vh;overflow:hidden;"
  >
    @if (!_drawerOpen)
    {
      <MudIconButton
        Icon="@Icons.Material.Filled.ChevronRight"
        OnClick="() => _drawerOpen = true"
        Color="Color.Primary"
        Class="ma-2"
        Style="position: fixed; left: 0; top: 0; z-index: 100; background-color: var(--mud-palette-background); box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
        aria-label="Open menu"
      />
    }

    <div
      class="chat-container px-2 pb-2 no-scrollbar"
      @ref="_chatContainerRef"
      style="overflow-y:auto; flex:1 1 auto;"
    >
      <MudPaper Elevation="0">
        <MudStack Spacing="4">
          @foreach (var m in _chatHistory)
          {
            if (m.IsUser)
            {
              <MudStack JustifyContent="FlexEnd">
                <div class="user-message-container">
                  <MudChatBubble
                    Variant="Variant.Text"
                    Class="user-message"
                  >
                    <UserMarkdown Markdown="@m.Text"/>
                  </MudChatBubble>
                  <div class="message-actions">
                    <span @onclick:stopPropagation="true">
                      <MudIconButton
                        Icon="@Icons.Material.Outlined.Refresh"
                        Size="Size.Small"
                        OnClick="@(() => HandleRegenerateMessage(m))"
                        aria-label="Regenerate"
                        Title="Regenerate"
                      />
                    </span>
                    <span @onclick:stopPropagation="true">
                      <MudIconButton
                        Icon="@Icons.Material.Filled.Edit"
                        Size="Size.Small"
                        OnClick="@(() => HandleEditMessage(m))"
                        aria-label="Edit"
                        Title="Edit"
                      />
                    </span>
                    <span @onclick:stopPropagation="true">
                      <MudIconButton
                        Icon="@Icons.Material.Filled.ContentCopy"
                        Size="Size.Small"
                        OnClick="@(async () => await HandleCopyMessage(m))"
                        aria-label="Copy"
                        Title="Copy"
                      />
                    </span>
                  </div>
                  <div class="user-message-hoverzone"></div>
                </div>
              </MudStack>
            }
            else
            {
              <MudStack JustifyContent="FlexStart">
                <div class="ai-message-container">
                  <AiMarkdown Markdown="@m.Text"/>
                  <div class="message-actions">
                    <span @onclick:stopPropagation="true">
                      <MudIconButton
                        Icon="@Icons.Material.Filled.ContentCopy"
                        Size="Size.Small"
                        OnClick="@(async () => await HandleCopyMessage(m))"
                        aria-label="Copy"
                        Title="Copy"
                      />
                    </span>
                    <span @onclick:stopPropagation="true">
                      <MudIconButton
                        Icon="@Icons.Material.Filled.MergeType"
                        Size="Size.Small"
                        OnClick="@(() => HandleBranchMessage(m))"
                        aria-label="Branch"
                        Title="Branch"
                      />
                    </span>
                    <span @onclick:stopPropagation="true">
                      <MudIconButton
                        Icon="@Icons.Material.Filled.Refresh"
                        Size="Size.Small"
                        OnClick="@(() => HandleRegenerateMessage(m))"
                        aria-label="Regenerate"
                        Title="Regenerate"
                      />
                    </span>
                  </div>
                  <div class="ai-message-hoverzone"></div>
                </div>
              </MudStack>
            }
          }
        </MudStack>
      </MudPaper>
    </div>

    <div class="input-area-container">
      <MudPaper Elevation="0" Class="pa-2 flex-shrink-0">
        <MudContainer Class="pa-0">
          <div style="display:flex;flex-direction:column;">
            <div style="display:flex;align-items:center;">
              <MudTextField
                @bind-Value="MessageText"
                Label="Enter your message"
                Variant="Variant.Outlined"
                AutoGrow="true"
                MaxLines="10"
                Class="flex-grow-1"
                Immediate="false"
                OnKeyUp="HandleKeyUp"
              />
            </div>
            <div
              style="display:flex;align-items:center;margin-top:8px;"
            >
              <MudSelect
                @bind-Value="ChatSelectedOption"
                Label="Select a model"
                Variant="Variant.Outlined"
                Margin="Margin.Dense"
                FitContent="true"
                Class="mr-2"
              >
                @foreach (var opt in _chatOptions)
                {
                  <MudSelectItem Value="@opt">@opt</MudSelectItem>
                }
              </MudSelect>
              <MudSelect
                @bind-Value="ThinkingSelectedOption"
                Label="Thinking"
                Variant="Variant.Outlined"
                Margin="Margin.Dense"
                FitContent="true"
                Class="mr-2"
              >
                @foreach (var opt in _thinkingOptions)
                {
                  <MudSelectItem Value="@opt">@opt</MudSelectItem>
                }
              </MudSelect>
              <MudToggleIconButton
                @bind-Toggled="_searchEnabled"
                Icon="@Icons.Material.Filled.Public"
                ToggledIcon="@Icons.Material.Filled.PublicOff"
                Color="Color.Primary"
                ToggledColor="Color.Secondary"
                aria-label="Toggle search"
                Class="ml-2"
              />
              <MudText Typo="Typo.body1" Class="ml-1">
                Search
              </MudText>
              <div
                style="margin-left:auto;display:flex;align-items:center;"
              >
                <MudIconButton
                  Icon="@Icons.Material.Filled.AttachFile"
                  Color="Color.Primary"
                  OnClick="AttachFile"
                  aria-label="Attach file"
                  Class="mr-2"
                />
                <MudButton
                  Variant="Variant.Filled"
                  Color="Color.Primary"
                  EndIcon="@Icons.Material.Filled.Send"
                  OnClick="SendMessage"
                  aria-label="Send message"
                  Disabled="@_isSendingMessage"
                >
                  Send
                </MudButton>
              </div>
            </div>
          </div>
        </MudContainer>
      </MudPaper>
    </div>
  </MudMainContent>
</MudLayout>

@code {
  private bool _drawerOpen = true;
  private bool _searchEnabled;
  private bool _needsScroll;
  private bool _isAtBottom = true;
  private bool _isSendingMessage = false;


  private ElementReference _chatContainerRef;

  private string UserEmail { get; set; } = "";
  private string MessageText { get; set; } = "";

  private string ChatSelectedOption { get; set; } = "DeepSeek v3";
  private string ThinkingSelectedOption { get; set; } = "Medium";

  private readonly List<string> _chatOptions = new()
  {
    "DeepSeek v3",
    "DeepSeek Prover v2",
    "Deepseek r1",
    "Gemini 2.5 Pro",
    "Gemini 2.5 Flash",
    "Gemini 2.0 Flash",
    "Qwen3 235B",
    "DeepSeek r1 v3 Chimera",
    "Gemma 3 27B",
    "Qwen3 30B",
    "llama-3.1-8b-instant"
  };

  private readonly List<string> _thinkingOptions = new()
  {
    "None",
    "Low",
    "Medium",
    "High"
  };

  private string? _chatId;
  private string _chatName = "New Chat";
  private List<ChatMessage> _chatHistory = new();
  private bool _chatIsPinned;

  private List<ChatDrawer.SidebarChat> SidebarChats = new();

  protected override async Task OnInitializedAsync()
  {
    UserEmail = await UserService.GetUserEmailAsync() ?? "Unknown";
    await LoadSidebarChatsAsync();
  }

  private async Task LoadSidebarChatsAsync()
  {
    var list = await ChatService.GetChatsAsync();
    SidebarChats = list
      .OrderByDescending(c => c.IsPinned)
      .ThenByDescending(c => c.LastUpdatedAt)
      .Select(c => new ChatDrawer.SidebarChat(c.Id.ToString(), c.Name, c.Model, c.IsPinned, c.LastUpdatedAt))
      .ToList();
  }

  private async Task CreateNewChat()
  {
    _chatId = null;
    _chatName = "New Chat";
    _chatHistory.Clear();
    _chatIsPinned = false;
    StateHasChanged();
  }

  private async Task LoadChat(ChatDrawer.SidebarChat chat)
  {
    // OOEE
    if (_chatId == chat.Id && _chatHistory.Any()) return; // Already loaded

    var full = await ChatService.GetChatAsync(Guid.Parse(chat.Id));
    _chatId = full.Id.ToString();
    _chatName = full.Name;
    ChatSelectedOption = full.Model;
    _chatIsPinned = full.IsPinned;
    _chatHistory = full.Messages
      .Select(m => new ChatMessage
      {
        IsUser = m.Role == "user",
        Text = m.Content
      })
      .ToList();
    _needsScroll = true;
    StateHasChanged();
  }

  private List<ServiceChatMessage> ToSharedMessages() =>
    _chatHistory.Select(m => new ServiceChatMessage
    {
      Role = m.IsUser ? "user" : "assistant",
      Content = m.Text
    }).ToList();

  [JSInvokable]
  public void SetAtBottom(bool atBottom) => _isAtBottom = atBottom;

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (firstRender)
    {
      await Js.InvokeVoidAsync(
        "chatScroll.onScroll",
        _chatContainerRef,
        DotNetObjectReference.Create(this)
      );
    }

    if (_needsScroll && _isAtBottom)
    {
      await ScrollManager.ScrollToBottomAsync(
        ".chat-container",
        ScrollBehavior.Smooth
      );
      _needsScroll = false;
    }
  }

  private async Task HandleKeyUp(KeyboardEventArgs args)
  {
    if (args.Key == "Enter" && !args.ShiftKey && !args.CtrlKey && !args.AltKey) // Send on Enter unless Shift is pressed
    {
        if (!string.IsNullOrWhiteSpace(MessageText))
        {
            await SendMessage();
        }
    }
  }

  private async Task SendMessage()
  {
    if (_isSendingMessage) return;

    var textToSend = MessageText.Trim();
    if (string.IsNullOrWhiteSpace(textToSend))
    {
      return;
    }
    
    _isSendingMessage = true;
    StateHasChanged(); // Update UI to reflect disabled send button

    _chatHistory.Add(new ChatMessage { IsUser = true, Text = textToSend });
    var userMessageTextForName = textToSend; // Store before clearing
    MessageText = "";
    _isAtBottom = true;
    _needsScroll = true;
    StateHasChanged();

    bool isNewChat = _chatId == null;
    Guid newChatGuid = Guid.Empty;

    if (isNewChat)
    {
      _chatName = "New Chat"; // Temporary name
      // Create chat with a placeholder name and the first user message for context
      // The actual first message (textToSend) will be part of the main conversation stream
      var initialMessagesForName = new List<ServiceChatMessage> {
          new() { Role = "user", Content = $"Generate a brief, relevant chat name (under 5 words, no quotes) for this conversation that starts with: \"{userMessageTextForName[..Math.Min(100, userMessageTextForName.Length)]}\"" }
      };
      
      string tempName = userMessageTextForName.Length <= 20 ? userMessageTextForName : userMessageTextForName.Substring(0, 20) + "...";


      var createReq = new ChatService.CreateChatRequest(
        tempName, // Use a temp name derived from the first message
        ChatSelectedOption, // Use the currently selected model for the chat itself
        new ChatService.ChatMessageDto[] { new ChatService.ChatMessageDto("user", userMessageTextForName) }, // Store the first user message
        _chatIsPinned
      );
      newChatGuid = await ChatService.CreateChatAsync(createReq);
      _chatId = newChatGuid.ToString();
      NavigationManager.NavigateTo($"/Chat?chatId={_chatId}", forceLoad: false);


      // Generate name using a fast model (e.g., llama-3.1-8b-instant)
      // This name generation is separate from the main chat flow.
      string generatedName = "";
      try
      {
          await foreach (var chunk in CompletionService.StreamCompletionAsync(
                           initialMessagesForName,
                           "llama-3.1-8b-instant", // Specific model for name generation
                           "Low" // Specific reasoning for name generation
                         ))
          {
            generatedName += chunk;
          }
          _chatName = !string.IsNullOrWhiteSpace(generatedName)
            ? generatedName.Trim().Trim('"', '\'').Replace("\n", " ").Truncate(50)
            : tempName;
      }
      catch(Exception ex)
      {
          Console.WriteLine($"Name generation failed: {ex.Message}");
          _chatName = tempName; // Fallback to temp name
      }
      // Update the chat with the generated name (messages are already set)
        var updateNameReq = new ChatService.UpdateChatRequest(
            _chatName,
            ChatSelectedOption,
            new ChatService.ChatMessageDto[] { new ChatService.ChatMessageDto("user", userMessageTextForName) },
            _chatIsPinned
        );
        await ChatService.UpdateChatAsync(newChatGuid, updateNameReq);
        await LoadSidebarChatsAsync(); // Refresh sidebar
    }


    var aiMessage = new ChatMessage { IsUser = false, Text = "" };
    _chatHistory.Add(aiMessage);
    _needsScroll = true;
    StateHasChanged();

    try
    {
      int chunkCount = 0;
      var lastUpdate = DateTime.UtcNow;
      // Use ToSharedMessages() which now includes the latest user message
      await foreach (var chunk in CompletionService.StreamCompletionAsync(
                       ToSharedMessages().Take(_chatHistory.Count -1).ToList(), // Send history *before* AI placeholder
                       ChatSelectedOption,
                       ThinkingSelectedOption // Pass selected thinking option
                     ))
      {
        aiMessage.Text += chunk;
        chunkCount++;
        _needsScroll = true;

        var now = DateTime.UtcNow;
        if ((now - lastUpdate).TotalMilliseconds >= 100 || chunkCount <= 5) // More frequent updates for initial chunks
        {
          lastUpdate = now;
          await InvokeAsync(StateHasChanged);
        }
      }
      await InvokeAsync(StateHasChanged); // Final update

      if (chunkCount == 0 && string.IsNullOrWhiteSpace(aiMessage.Text))
      {
        aiMessage.Text = "[No response received from AI]";
        await InvokeAsync(StateHasChanged);
      }
    }
    catch (Exception ex)
    {
      aiMessage.Text = $"[Error: {ex.Message}]";
      Console.WriteLine($"Error streaming completion: {ex}");
      await InvokeAsync(StateHasChanged);
    }
    finally
    {
        _isSendingMessage = false;
        StateHasChanged(); // Re-enable send button
    }

    if (Guid.TryParse(_chatId, out var cId))
    {
      var updateReq = new ChatService.UpdateChatRequest(
        _chatName,
        ChatSelectedOption,
        ToSharedMessages()
          .Select(msg => new ChatService.ChatMessageDto(msg.Role, msg.Content))
          .ToArray(),
        _chatIsPinned
      );
      await ChatService.UpdateChatAsync(cId, updateReq);
      await LoadSidebarChatsAsync();
      }
  }

  private void AttachFile() => Console.WriteLine("Attach file clicked.");

  private async Task PinChat(ChatDrawer.SidebarChat chat)
  {
    if (Guid.TryParse(chat.Id, out var chatId))
    {
      await ChatService.PinChatAsync(chatId, !chat.IsPinned);
      await LoadSidebarChatsAsync(); // This will re-sort and update UI
      if (_chatId == chat.Id) _chatIsPinned = !chat.IsPinned; // Update current chat's pinned state
      StateHasChanged();
    }
  }

  private async Task DeleteChat(ChatDrawer.SidebarChat chat)
  {
    if (Guid.TryParse(chat.Id, out var chatId))
    {
      await ChatService.DeleteChatAsync(chatId);
      SidebarChats.RemoveAll(c => c.Id == chat.Id); // Ensure correct removal
      if (_chatId == chat.Id) {
          // If active chat is deleted, load the next available or create new
          if (SidebarChats.Any()) {
              await LoadChat(SidebarChats.First());
          } else {
              await CreateNewChat();
          }
      }
      StateHasChanged();
    }
  }

  private async Task HandleChatRenamed(ChatDrawer.SidebarChat updatedChat)
  {
    var fullChat = await ChatService.GetChatAsync(Guid.Parse(updatedChat.Id));
    var updateReq = new ChatService.UpdateChatRequest(
      updatedChat.Name,
      updatedChat.Model,
      fullChat.Messages,
      updatedChat.IsPinned
    );
    await ChatService.UpdateChatAsync(Guid.Parse(updatedChat.Id), updateReq);
    await LoadSidebarChatsAsync();
    if (_chatId == updatedChat.Id) _chatName = updatedChat.Name;
    StateHasChanged();
  }

  private async Task HandleRegenerateMessage(ChatMessage messageToRegen)
  {
    if (_isSendingMessage) return;
    _isSendingMessage = true;
    StateHasChanged();

    var idx = _chatHistory.IndexOf(messageToRegen);
    if (idx == -1) {
        _isSendingMessage = false;
        StateHasChanged();
        return;
    }

    List<ServiceChatMessage> messagesToSend;
    ChatMessage targetAiMessage;

    if (messageToRegen.IsUser) // Regenerate AI response for this user message
    {
        // Remove AI messages from this user message onwards
        _chatHistory.RemoveAll(m => _chatHistory.IndexOf(m) > idx && !m.IsUser);
        // If the next message is an AI message, remove it.
        if (idx + 1 < _chatHistory.Count && !_chatHistory[idx + 1].IsUser)
        {
            _chatHistory.RemoveAt(idx + 1);
        }

        messagesToSend = _chatHistory.Take(idx + 1) // Messages up to and including the user message
            .Select(x => new ServiceChatMessage { Role = x.IsUser ? "user" : "assistant", Content = x.Text })
            .ToList();
        
        targetAiMessage = new ChatMessage { IsUser = false, Text = "" };
        if (idx + 1 < _chatHistory.Count) _chatHistory.Insert(idx + 1, targetAiMessage);
        else _chatHistory.Add(targetAiMessage);
    }
    else // Regenerate this AI message (based on history up to the preceding user message)
    {
        _chatHistory[idx] = new ChatMessage { IsUser = false, Text = "" }; // Clear current AI message
        targetAiMessage = _chatHistory[idx];

        messagesToSend = _chatHistory.Take(idx) // Messages up to (but not including) this AI message
            .Select(x => new ServiceChatMessage { Role = x.IsUser ? "user" : "assistant", Content = x.Text })
            .ToList();
    }
    
    _needsScroll = true;
    StateHasChanged();

    try
    {
        int chunkCount = 0;
        var lastUpdate = DateTime.UtcNow;
        await foreach (var chunk in CompletionService.StreamCompletionAsync(
                           messagesToSend,
                           ChatSelectedOption,
                           ThinkingSelectedOption // Pass selected thinking option
                         ))
        {
            targetAiMessage.Text += chunk;
            chunkCount++;
            _needsScroll = true;

            var now = DateTime.UtcNow;
            if ((now - lastUpdate).TotalMilliseconds >= 100 || chunkCount <= 5)
            {
                lastUpdate = now;
                await InvokeAsync(StateHasChanged);
            }
        }
        await InvokeAsync(StateHasChanged);

        if (chunkCount == 0 && string.IsNullOrWhiteSpace(targetAiMessage.Text))
        {
            targetAiMessage.Text = "[No response received from AI for regeneration]";
            await InvokeAsync(StateHasChanged);
        }
    }
    catch (Exception ex)
    {
        targetAiMessage.Text = $"[Error regenerating: {ex.Message}]";
        Console.WriteLine($"Error regenerating message: {ex}");
        await InvokeAsync(StateHasChanged);
    }
    finally
    {
        _isSendingMessage = false;
        StateHasChanged();
    }

    if (Guid.TryParse(_chatId, out var cId))
    {
        var updateReq = new ChatService.UpdateChatRequest(
            _chatName,
            ChatSelectedOption,
            ToSharedMessages().Select(msg => new ChatService.ChatMessageDto(msg.Role, msg.Content)).ToArray(),
            _chatIsPinned
        );
        await ChatService.UpdateChatAsync(cId, updateReq);
        // No need to reload all sidebar chats, just ensure current one is fine.
        // If regeneration changes last update time, that could be handled.
    }
  }

  private void HandleEditMessage(ChatMessage m) {
    // Basic implementation: set message text to input, allow resending.
    // More advanced: allow editing in place, then decide how to handle history.
    MessageText = m.Text; // Put text back in input
    // Remove this message and subsequent ones if it's a user message?
    // Or just allow editing and resending as a new message?
    // For now, just populates input. User can modify and send as new.
    Snackbar.Add("Message content copied to input field for editing.", Severity.Info);
    StateHasChanged(); // To reflect MessageText update if input is bound
  }


  private async Task HandleCopyMessage(ChatMessage m)
  {
    try
    {
      await Js.InvokeVoidAsync("navigator.clipboard.writeText", m.Text);
      Snackbar.Add("Message copied to clipboard", Severity.Success);
    }
    catch (Exception ex)
    {
      Snackbar.Add($"Failed to copy: {ex.Message}", Severity.Error);
    }
  }

  private async Task HandleBranchMessage(ChatMessage messageToBranchFrom)
  {
    var idx = _chatHistory.IndexOf(messageToBranchFrom);
    if (idx == -1) return;

    var branchMessages = _chatHistory.Take(idx + 1)
      .Select(x => new ServiceChatMessage { Role = x.IsUser ? "user" : "assistant", Content = x.Text })
      .ToList();

    var branchName = $"Branch: {_chatName}".Truncate(50);
    var createReq = new ChatService.CreateChatRequest(
      branchName,
      ChatSelectedOption, // Use current model for the new branch
      branchMessages.Select(m => new ChatService.ChatMessageDto(m.Role, m.Content)).ToArray(),
      false // New branches are not pinned by default
    );
    var newId = await ChatService.CreateChatAsync(createReq);

    await LoadSidebarChatsAsync(); // Refresh sidebar to include the new chat

    var newSidebarChat = SidebarChats.FirstOrDefault(c => c.Id == newId.ToString());
    if (newSidebarChat != null)
    {
      await LoadChat(newSidebarChat); // Load the newly created branched chat
      Snackbar.Add("Chat branched successfully", Severity.Success);
    }
    else
    {
      // Fallback if not found immediately (should be rare)
      _chatId = newId.ToString();
      _chatName = branchName;
      _chatHistory = branchMessages.Select(m => new ChatMessage { IsUser = m.Role == "user", Text = m.Content }).ToList();
      _chatIsPinned = false;
      NavigationManager.NavigateTo($"/Chat?chatId={_chatId}", forceLoad: false);
      Snackbar.Add("Chat branched, but could not auto-load. Please select from sidebar.", Severity.Warning);
      StateHasChanged();
    }
  }

  private record ChatMessage
  {
    public string Id { get; init; } = Guid.NewGuid().ToString();
    public bool IsUser { get; init; }
    public string Text { get; set; } = "";
  }
}
